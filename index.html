<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game</title>
</head>

<body style="margin: 0">
  <canvas></canvas>
</body>
<script>
  const canvas = document.querySelector("canvas");
  const context = canvas.getContext("2d");

  const width = (canvas.width = innerWidth);
  const height = (canvas.height = innerHeight);

  const gravity = 0.5;
  const jumpForce = -10;
  const obstacleWidth = 75;
  const speed = -10;
  // const speed = screen.width < 700 ? -5 : -10

  let spawnTimer = 0;
  let score = 0;
  let highScore = 0
  let isJumping = false;
  let gameOver = false;
  let gameStarted = false;

  const player = {
    width: 50,
    height: 50,
    x: width / 8,
    y: height / 2,
    vy: 0,
  };
  const obstacles = [];
  let particles = [];

  class Particle {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.vx = Math.random() * 2 - 2;
      this.vy = Math.random() * 2 - 1;
      this.alpha = 1;
    }

    update() {
      this.x += this.vx;
      this.y += this.vy;
      this.alpha -= 0.05;
    }

    // draw() {
    //   context.globalAlpha = this.alpha;
    //   context.fillStyle = 'hsl(0, 100%, 50%)';
    //   context.fillRect(this.x, this.y, 10, 10);
    //   context.globalAlpha = 1;
    // }
    draw() {
      const gradient = context.createLinearGradient(this.x, this.y, this.x + 10, this.y + 10);
      gradient.addColorStop(0, 'hsl(0, 100%, 50%)');
      gradient.addColorStop(0.5, 'hsl(25, 100%, 50%)');
      gradient.addColorStop(1, 'hsl(50, 100%, 50%)')

      context.globalAlpha = this.alpha;
      context.fillStyle = gradient;
      context.fillRect(this.x, this.y, 10, 10);
      context.globalAlpha = 1;
    }
  }


  function createObstacle() {
    const gap = Math.floor(Math.random() * 300) + 150; // gap between 150 and 450
    const interval = Math.floor(Math.random() * 1000) + 500; // interval between 500 and 1500

    const gapY = Math.floor(Math.random() * (height - gap));
    const upperPipe = {
      x: width,
      y: 0,
      width: obstacleWidth,
      height: gapY,
      speed,
      passed: false,
    };
    const lowerPipe = {
      x: width,
      y: gapY + gap,
      width: obstacleWidth,
      height: height - gapY - gap,
      speed,
      passed: false,
    };
    obstacles.push(upperPipe, lowerPipe);

    spawnTimer = setTimeout(createObstacle, interval);
  }

  function spawnParticles() {
    for (let i = 0; i < 2; i++) {
      particles.push(new Particle(player.x, player.y + player.height));
    }
  }

  function jump(event) {
    if (
      event.type == "touchstart" ||
      (event.type == "keydown" && event.key == " " && !isJumping)
    ) {
      player.vy = jumpForce;
      isJumping = true;
    }
    if (event.type == "keyup" && event.key == " ") isJumping = false;
  }

  canvas.addEventListener("touchstart", startGame);
  document.addEventListener("keydown", startGame);

  canvas.addEventListener("touchstart", jump);
  document.addEventListener("keydown", jump);
  document.addEventListener("keyup", jump);

  function isCollide(a, b) {
    const margin = 5;
    return !(
      a.y + a.height - margin < b.y + margin ||
      a.y + margin > b.y + b.height - margin ||
      a.x + a.width - margin < b.x + margin ||
      a.x + margin > b.x + b.width - margin
    );
  }

  function update() {
    player.y += player.vy;
    player.vy += gravity;

    if (!gameOver && gameStarted) {
      spawnParticles();
    }

    if (player.y + player.height / 2 > height) {
      player.y = height - player.height;
      gameOver = true;
    }
    if (player.y < 0) player.y = 0;

    for (const obstacle of obstacles) {
      obstacle.x += obstacle.speed;

      if (
        !obstacle.passed &&
        obstacle.y === 0 &&
        obstacle.x + obstacle.width < player.x
      ) {
        score++;
        obstacle.passed = true;
      }
    }

    if (obstacles.length > 0) {
      if (obstacles[0].x + obstacles[0].width < 0) {
        obstacles.splice(0, 2);
      }
    }

    for (const obstacle of obstacles) {
      if (isCollide(player, obstacle)) {
        gameOver = true;
      }
    }
    for (const particle of particles) {
      particle.update();
    }
    particles = particles.filter(particle => particle.alpha > 0);

  }

  function draw() {
    context.fillStyle = 'hsl(0, 0%, 10%)';
    context.globalAlpha = 0.25
    context.fillRect(0, 0, width, height);
    context.globalAlpha = 1
    for (const particle of particles) {
      particle.draw();
    }
    context.fillStyle = 'hsl(0, 0%, 80%)';
    context.fillRect(player.x, player.y, player.width, player.height);
    for (let i = 0; i < obstacles.length; i++) {
      context.fillRect(
        obstacles[i].x,
        obstacles[i].y,
        obstacles[i].width,
        obstacles[i].height
      );
    }
    context.fillStyle = 'hsl(0, 0%, 80%)';
    drawText(`${score}`, width / 2, height / 8);
  }

  function loop() {
    if (!gameOver) {
      draw();
      update();
      requestAnimationFrame(loop);
    } else reset();
  }

  function startGame(event) {
    if (
      !gameStarted &&
      ((event.type == "keydown" && event.key == " ") ||
        event.type == "touchstart")
    ) {
      createObstacle();
      gameStarted = true;
      document.removeEventListener("keydown", startGame);
      canvas.removeEventListener("touchstart", startGame);
      requestAnimationFrame(loop);
    }
  }

  function reset() {
    clearTimeout(spawnTimer);
    obstacles.splice(0, obstacles.length);
    gameStarted = false;
    gameOver = false;
    player.x = width / 8;
    player.y = height / 2;
    player.vy = 0;
    if (score > highScore) {
      highScore = score;
    }
    score = 0;
    document.addEventListener("keydown", startGame);
    canvas.addEventListener("touchstart", startGame);
    drawText(`Highscore ${highScore}`, width / 2, height / 4);
    drawText(
      `${screen.width < 700 ? "Touch" : "Space"}`,
      width / 2,
      height / 2
    );
  }

  function drawText(content, posX, posY) {
    context.textBaseline = "middle";
    context.textAlign = "center";
    context.font = "small-caps 700 2rem sans-serif";
    context.fillText(content, posX, posY);
  }

  drawText(
    `${screen.width < 700 ? "Touch" : "Space"}`,
    width / 2,
    height / 2
  );
</script>

</html>